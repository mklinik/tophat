% !TEX root=../main.tex

%% Helpers %%

\newmacro{newrule}[4][2]
  {\newmacro{#1}{\inferrule*[lab={#1},right={$#2$}]
    {#3}
    {#4}}}
\newmacro{userule}
  {\usemacro}
\newmacro{refrule}
  {\textsc}

\newif\ifstateful
\statefulfalse
\newmacro{st}[1]
  {\ifstateful{, #1}\else{}\fi}


%% Typing %%

\newmacro{RelationT}
  {\Gamma\st{\Sigma} \infers e : \tau}

\newrule{T-Pure}
  {\Gamma\st{\Sigma} \infers e : \tau}
  {\Gamma\st{\Sigma} \infers \Done e : \Task \tau}

\newrule{T-Fail}
  {\ }
  {\Gamma\st{\Sigma} \infers \Fail : \Task \tau}

\newrule{T-Edit}
  {\Gamma\st{\Sigma} \infers v : \tau}
  {\Gamma\st{\Sigma} \infers \Edit v : \Task \tau}

\newrule{T-Empty}
  {\ }
  {\Gamma\st{\Sigma} \infers \Empty \tau : \Task \tau}

\newrule{T-Watch}
  {\Gamma, \Sigma \infers \Sigma(l) : \tau}
  {\Gamma, \Sigma \infers \Watch l : \Task \tau}

\newrule{T-Then}
  {\Gamma\st{\Sigma} \infers t_1 : \Task \tau_1 \\
   \Gamma\st{\Sigma} \infers e : \tau_1 \to \Task \tau_2}
  {\Gamma\st{\Sigma} \infers t_1 \Then e : \Task \tau_2}

\newrule{T-When}
  {\Gamma\st{\Sigma} \infers t_1 : \Task \tau_1 \\
   \Gamma\st{\Sigma} \infers e : \tau_1 \to \Task \tau_2}
  {\Gamma\st{\Sigma} \infers t_1 \When e : \Task \tau_2}

\newrule{T-And}
  {\Gamma\st{\Sigma} \infers t_1 : \Task \tau_1 \\
   \Gamma\st{\Sigma} \infers t_2 : \Task \tau_2}
  {\Gamma\st{\Sigma} \infers t_1 \And t_2 : \Task\,(\tau_1 \times \tau_2)}

\newrule{T-Or}
  {\Gamma\st{\Sigma} \infers t_1 : \Task \tau \\
   \Gamma\st{\Sigma} \infers t_2 : \Task \tau }
  {\Gamma\st{\Sigma} \infers t_1 \Or t_2 : \Task \tau}


%% Evaluation %%

\newmacro{RelationV}
  {e \downto v}


%% Normalisation %%

\newmacro{RelationN}
  {t\st{s} \normalise t'\st{s'}}

\newrule{N-Pure}
  { }
  {\Done v\st{s} \normalise \Done v\st{s}}

\newrule{N-Fail}
  { }
  {\Fail\st{s} \normalise \Fail\st{s}}

\newrule{N-Edit}
  { }
  {\Edit v\st{s} \normalise \Edit v\st{s}}

\newrule{N-Empty}
  { }
  {\Empty \tau\st{s} \normalise \Empty \tau\st{s}}

\newrule{N-Watch}
  { }
  {\Watch l\st{s} \normalise \Watch l\st{s}}

\newrule{N-Then}[t_1' = \Done v]
  {t_1\st{s} \normalise t_1'\st{s'}   \\
   e\ v \downto t_2       \\
   t_2\st{s'} \normalise t_2'\st{s''} }
  {t_1 \Then e\st{s} \normalise t_2'\st{s''}}

\newrule{N-ThenEval}[t_1' \neq \Done v]
  {t_1\st{s} \normalise t_1'\st{s'}}
  {t_1 \Then e\st{s} \normalise t_1' \Then e\st{s'}}

\newrule{N-WhenStay}[\Value(t_1) = \nothing]
  {\ }
  {t_1 \When e\st{s} \normalise t_1 \When e\st{s}}

\newrule{N-WhenFail}[\Value(t_1) = v \land (t_2 = \Fail \lor t_2 = t_3 \Or t_4)]
  {e\ v \downto t_2}
  {t_1 \When e\st{s} \normalise t_1 \When e\st{s}}

\newrule{N-WhenNext}[\Value(t_1) = v \land (t_2 \neq \Fail \lor t_2 \neq t_3 \Or t_4)]
  {e\ v \downto t_2    \\
   t_2\st{s} \normalise t_2'\st{s'} }
  {t_1 \When e\st{s} \normalise t_2' \When e\st{s'}}

\newrule{N-And}[t_1' = \Done v_1 \land t_2' = \Done v_2]
  {t_1\st{s}  \normalise t_1'\st{s'}  \\
   t_2\st{s'} \normalise t_2'\st{s''} }
  {t_1 \And t_2\st{s} \normalise \Done \{v_1, v_2\}\st{s}}

\newrule{N-AndEval}[t_1' \neq \Done v_1 \lor t_2' \neq \Done v_2]
  {t_1\st{s}  \normalise t_1'\st{s'}  \\
   t_2\st{s'} \normalise t_2'\st{s''} }
  {t_1 \And t_2\st{s} \normalise t_1' \And t_2'\st{s}}

\newrule{N-OrEval}[t_1' \neq \Done v_1 \land t_2' \neq \Done v_2]
  {t_1\st{s}  \normalise t_1'\st{s'}  \\
   t_2\st{s'} \normalise t_2'\st{s''} }
  {t_1 \Or t_2\st{s} \normalise t_1' \Or t_2'\st{s}}


%% Handling %%

\newmacro{RelationH}
  {t\st{s} \handle{\eta} t'\st{s'}}

\newrule{H-Change}[v, v' : \tau]
  { }
  {\Edit v\st{s} \handle{v'} \Edit v'\st{s}}

\newrule{H-Clear}
  { }
  {\Edit v\st{s} \handle{\Clear} \Empty\st{s}}

\newrule{H-Enter}[v' : \tau]
  { }
  {\Empty \tau\st{s} \handle{v'} \Edit v'\st{s}}

\newrule{H-Store}[\Sigma(l), v' : \tau]
  { }
  {\Watch l, s \handle{v'} \Watch l, [l \mapsto v']s}

\newrule{H-Stay'}[\Value(t_1) = \nothing]
  {\ }
  {t_1 \Then e\st{s} \handle{\Next} t_1 \Then e\st{s}}

\newrule{H-Next'}[\Value(t_1) = v]
  {e\ v \downto t_2    \\
   t_2\st{s} \normalise t_2'\st{s'} }
  {t_1 \Then e\st{s} \handle{\Next} t_2'\st{s'}}

\newrule{H-Stay}[\Value(t_1) = \nothing]
  {\ }
  {t_1 \When e\st{s} \handle{\Execute \pi} t_1 \When e\st{s}}

\newrule{H-Fail}[\Value(t_1) = v \land t_2 = \Fail]
  {e\ v \downto t_2    \\
   t_2\st{s} \handle{\Pick \pi} t_2'\st{s'} }
  {t_1 \When e\st{s} \handle{\Execute \pi} t_1 \When e\st{s}}

\newrule{H-Next}[\Value(t_1) = v \land t_2 \neq \Fail]
  {e\ v \downto t_2    \\
   t_2\st{s} \handle{\Pick \pi} t_2'\st{s'} }
  {t_1 \When e\st{s} \handle{\Execute \pi} t_2'\st{s'}}

\newrule{H-PassS}
  {t_1\st{s} \handle{\eta} t_1'\st{s'}}
  {t_1 \Then e\st{s} \handle{\eta} t_1' \Then e\st{s'}}

\newrule{H-Pass}[\eta \neq \Execute \pi]
  {t_1\st{s} \handle{\eta} t_1'\st{s'}       \\
   t_1' \When e\st{s'} \normalise t_2\st{s''} }
  {t_1 \When e\st{s} \handle{\eta} t_2\st{s''}}

\newrule{H-First}[t_1 \neq \Fail]
  {\ }
  {t_1 \Or t_2\st{s} \handle{\Pick \First} t_1\st{s}}

\newrule{H-Second}[t_2 \neq \Fail]
  {\ }
  {t_1 \Or t_2\st{s} \handle{\Pick \Second} t_2\st{s}}

\newrule{H-Other}[t_2 \neq \Fail]
  {t_2\st{s} \handle{\Pick \pi} t_2'\st{s'}}
  {t_1 \Or t_2\st{s} \handle{\Pick \Other \pi} t_2'\st{s'}}

\newmacro{AndOr}{\Both}

\newrule{H-Left}
  {t_1\st{s} \handle{\eta} t_1'\st{s'} }
  {t_1 \AndOr t_2\st{s} \handle{\Left \eta} t_1' \AndOr t_2\st{s'}}

\newrule{H-Right}
  {t_2\st{s} \handle{\eta} t_2'\st{s'} }
  {t_1\st{s} \AndOr t_2 \handle{\Right \eta} t_1 \AndOr t_2'\st{s'}}

\newrule{H-Fallback}
  { }
  {t\st{s} \handle{\eta} t\st{s}}
