% !TEX root=../pldi2019.tex

\section{Semantics}

  \subsection{Layers}

  \subsection{Evaluation semantics}

  \begin{equation*}
    \boxed{\RelationV}
  \end{equation*}

  \begin{mathpar}
    \userule{E-Value}\\
    \userule{E-App}\\
    \userule{E-IfTrue}\quad
    \userule{E-IfFalse}\\
    \userule{E-Pair}\quad
    \userule{E-At}\\
    \userule{E-Ref}\\
    \userule{E-Deref}\quad
    \userule{E-Assign}\\
    \userule{E-Edit}\quad
    \userule{E-Fill}\\
    \userule{E-Update}\quad
    \userule{E-Fail} \\
    \userule{E-Then}\quad
    \userule{E-Next} \\
    \userule{E-And} \quad
    \userule{E-Or}\\
    \userule{E-Xor}
  \end{mathpar}

  \subsection{Observation semantics}
    \subsubsection{Task value}

    \begin{flalign*}
      \begin{array}{lcl}
        \multicolumn{3}{l}{\Value : \mathrm{Tasks} \rightharpoonup \mathrm{Values}} \\
        \Value(\Edit v, s)       &=& v \\
        \Value(\Enter \tau, s)   &=& \bot \\
        \Value(\Update l, s)  &=& s(l) \\
        \Value(\Fail, s)         &=& \bot \\
        \Value(t_1 \Then e_2, s) &=& \bot \\
        \Value(t_1 \Next e_2, s) &=& \bot \\
        \Value(t_1 \And t_2, s)  &=& \left\{
          \begin{array}{ll}
            \tuple{v_1, v_2}  & \when\ \Value(t_1, s) = v_1 \land \Value(t_2, s) = v_2 \\
            \bot              & \otherwise
          \end{array}
        \right. \\
        \Value(t_1 \Or t_2, s)   &=& \left\{
          \begin{array}{ll}
            v_1               & \when\ \Value(t_1, s) = v_1 \\
            v_2               & \when\ \Value(t_1, s) = \bot \lor \Value(t_2, s) = v_2 \\
            \bot              & \otherwise
          \end{array}
        \right. \\
        \Value(t_1 \Xor t_2, s)  &=& \bot\\
        \Value(u @ t, s)  &=& \Value(t,s)
      \end{array} & &&
    \end{flalign*}

    \subsubsection{Inputs}

    \begin{flalign*}
      \begin{array}{lcl}
        \multicolumn{3}{l}{\Inputs : \mathrm{Tasks} \to \powerset(\mathrm{Inputs})} \\
        \Inputs(\Edit v:\Task\tau)       &=& \set{v':\tau, \Empty} \\
        \Inputs(\Enter \tau)   &=& \set{v':\tau} \\
        \Inputs(\Update l:\Task\tau)     &=& \set{v':\tau} \\
        \Inputs(\Fail)         &=& \set{} \\
        \Inputs(t_1 \Then e_2) &=& \Inputs(t_1) \\
        \Inputs(t_1 \Next e_2) &=& \Inputs(t_1) \cup \set{\Continue\mid \Value{(t_1)}\neq \bot \wedge \neg\Failing{(e_2 \Value{(t_1)}\normalise)}} \\
        \Inputs(t_1 \And t_2)  &=& \set{\First\ i \mid i \in \Inputs(t_1)} \cup \set{\Second\ i \mid i \in \Inputs(t_2)} \\
        \Inputs(t_1 \Or t_2)   &=& \set{\First\ i \mid i \in \Inputs(t_1)} \cup \set{\Second\ i \mid i \in \Inputs(t_2)} \\
        \Inputs(e_1 \Xor e_2)  &=& \set{\Left, \Right} \\
        \Inputs(u_1 @ t)       &=& \set{u_2 @ i\mid u_2 @ i \in \Inputs(t)} \cup \set{u_1 @ i\mid i\in \Inputs(t)}
      \end{array} & &&
    \end{flalign*}

    \subsubsection{Failing}

    \begin{flalign*}
      \begin{array}{lcl}
        \multicolumn{3}{l}{\Failing : \mathrm{Tasks} \to \mathrm{Booleans}} \\
        \Failing(\Edit v)       &=& \False \\
        \Failing(\Enter \tau)   &=& \False \\
        \Failing(\Update l)     &=& \False \\
        \Failing(\Fail)         &=& \True \\
        \Failing(t_1 \Then e_2) &=& \Failing(t_1) \\
        \Failing(t_1 \Next e_2) &=& \Failing(t_1) \\
        \Failing(t_1 \And t_2)  &=& \Failing(t_1) \wedge \Failing(t_2) \\
        \Failing(t_1 \Or t_2)   &=& \Failing(t_1) \wedge \Failing(t_2) \\
        \Failing(t_1 \Xor t_2)  &=& \False\\
        \Failing(u @ t)         &=& \Failing(t)
      \end{array} & &&
    \end{flalign*}


    \subsubsection{User Interface }

  \subsection{Normalisation semantics}

  \begin{equation*}
    \boxed{\RelationN}
  \end{equation*}

  \paragraph{Step}
  \begin{mathpar}
    \userule{N-ThenStay} \\
    \userule{N-ThenFail} \\
    \userule{N-ThenCont}
  \end{mathpar}

  \paragraph{Choose}
  \begin{mathpar}
    \userule{N-OrLeft} \\
    \userule{N-OrRight} \\
    \userule{N-OrNone}
  \end{mathpar}

  \paragraph{Congruence}
  \begin{mathpar}
    \userule{N-Next} \\
    \userule{N-And}
  \end{mathpar}

  \paragraph{Ready}
  \begin{mathpar}
    \userule{N-Edit} \qquad \userule{N-Fill} \qquad \userule{N-Update} \\
    \userule{N-Fail} \qquad \userule{N-Xor}
  \end{mathpar}

  \paragraph{Driving}
  \begin{mathpar}
    \userule{N-Eval}
  \end{mathpar}

  \subsection{Handling semantics}


  \begin{equation*}
    \boxed{\RelationH}
  \end{equation*}

  \paragraph{Editing}
  \begin{mathpar}
    \userule{H-Change} \qquad \userule{H-Empty}\\
    \userule{H-Fill} \\
    \userule{H-Update}
  \end{mathpar}

  \paragraph{Continuing}
  \begin{mathpar}
    \userule{H-PickLeft}\\
    \userule{H-PickRight} \\
    \userule{H-Next}
  \end{mathpar}

  \paragraph{Passing}
  \begin{mathpar}
    \userule{H-PassThen} \qquad \userule{H-PassNext} \\
    \userule{H-FirstAnd} \qquad \userule{H-SecondAnd} \\
    \userule{H-FirstOr}  \qquad \userule{H-SecondOr}\\
    \userule{H-Assign}
  \end{mathpar}


  \subsubsection{Driving}

  \begin{equation*}
    \boxed{\RelationD}
  \end{equation*}

  \begin{mathpar}
    \userule{D-Main}
  \end{mathpar}
