% !TEX root=../main.tex

\section{Just an editor}

Till now we don't have any interaction with the end user.
The only things we can create are pure task, containing a value.
It is kind of hard to claim we model \emph{interactive} workflows without any user interaction at all.
% At the core of interactive workflows are user interaction.
An end user should be able to enter information into the system,
clear it, reenter it et cetera.
This is modelled by an \emph{editor}.
Editors may or may not contain a current value.
When an editor has a value, it can be \emph{changed} or \emph{cleared}.
When it is empty, a value can be \emph{reentered}.

For this purpose, we extend our task language with two constructs:
a valued editor $\Edit v$ and an empty editor $\Empty \tau$.
\begin{grammar}
  Tasks & t & ::=& \ldots      & \\
        &   &\mid& \Edit v     & – Valued editor \\
        &   &\mid& \Empty \tau & – Empty editor \\
\end{grammar}

Valued editors contain a value $v$ and therefore inherit the type of $v$.
This is expressed by the following typing rule for edit.
\begin{equation*}
  \TEdit
\end{equation*}
Empty editors do not have a value,
but, because we strive to a fully typed system,
we like to assign a type to them.
We have two options to solve this:
\begin{enumerate*}
  \item let the empty editor have a polymorphic type;
  \item annotate empty editors with a type and use that.
\end{enumerate*}
The first option sounds appealing, however, consider the following use case.
We start with an editor containing the value two: $\Edit 2$.
The user can change this value, as long as it is an integer,
for example to five: $\Edit 5$.
Clearing the value results in an empty editor: $\Empty$.
Now, is the user allowed to enter a value of some other type?
That is, can we now enter a string?
This would change the type of the editor!
We need to keep track of the type of values that can be entered into an empty editor
and therefore we choose to annotate them with a type.
The typing rule becomes:
\begin{equation*}
  \TEmpty
\end{equation*}


\subsection{Events}

To interact with an editor,
we should interact with the user with some kind of interface.
In a graphical setting,
we can present the user an input box.
The user can than change and clear values continuously.
In a text oriented world,
we can print out the current value of an editor
and prompt the user for a new value
or a command to clear the editor.

\endinput

Editors let us view and change a value in the system.
However, an editor can also have no value at all.
This is the case when the user clears the value.
