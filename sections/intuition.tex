% !TEX root=../icfp2019.tex



\section{Intuition}
\label{sec:intuition}

This section gives an overview over the core concepts of task-oriented programming.



\subsection{Tasks model real world collaborations between people and machines}

The central objective of \TOP is to \emph{coordinate collaboration}.
The basic building blocks of \TOPHAT are editors and combinators.
Editors are tasks with which users interact directly.
Combinators express ways in which people can work together.
Tasks can be executed after each other, at the same time, or conditionally.
This motivates the combinators step, parallel, and choice.


\subsection{Tasks are reusable}

Tasks are modular in the following ways.
First, larger tasks are composed from smaller ones.
Second, tasks are first-class, they can be arguments and results of functions.
Third, tasks can be values of other tasks.
These aspects make it possible for programmers to model custom collaboration patterns.

\begin{example}[Twice]

A higher-order function which executes a given task twice.
The task value of the first execution is ignored.

\fixme{Is that our official syntax?}
\begin{TASK}
  let twice : Task $\tau$ -> Task $\tau$ = \t : Task $\tau$. t >>? \x : $\tau$
\end{TASK}
\qed

\end{example}



\subsection{Tasks are driven by user input}


Input events drive evaluation of tasks.
When the system receives a valid event, it applies the event to the current task, which results in a new task.
In this way the system communicates with the environment.

In \TOPHAT, editors are the basic method of communication with the environment.
There are different editors, denoted by different box symbols.
An editor of the form $\Edit v$, where $v$ is of type $\tau$, reacts to two kinds of events:
First, change events $v$ with a value of type $\tau$ and second, clear events $\Empty$ which empty the editor.

The sole purpose of editors is to interact with the user by retaining the last value that has been sent to them.
There are no output events.
As values of editors can be observed, for example by a user interface, editors serve as facilities for both input and output.
An empty editor $\Enter \tau$ stands for a prompt to input data, while a filled editor can be seen either as outputting its value, or as an input that comes with a default value.

\begin{example}[Vending machine]
\label{Vending machine}

This example demonstrates external communication and choice.
It is a vending machine that dispenses a small biscuit for one coin and a large biscuit for two coins.
\begin{TASK}
  let vend : Task String = enter Int >>? \n. if n == 1 then edit "small"
    else if n == 2 then edit "large"
    else fail
\end{TASK}
The editor $\Enter \Int$ asks the user to enter an amount of money.
This editor stands for a coin slot in a real machine that freely accepts and returns coins.
There is a continue button that is initially disabled, due to the fact that the right hand side of the step combinator results in $\Fail$.
When the user has inserted exactly 1 or 2 coins, the continue button becomes enabled.
When the user presses the continue button, the machine dispenses either a large or a small biscuit, depending on the amount of money. \qed

\end{example}



\subsection{Tasks can be observed}

Several observations can be made of tasks.
One of those is determining the value of a task $\Value(t)$.
Not all tasks have a value, for example the empty editor $\Enter \tau$, which makes $\Value$ a partial function.

Another observation is the set of events a task can react to.
This is important for generating user interfaces.
For example, the task $\Edit 5$ can react to value events $v$ and empty events $\Empty$.

In order to render a user interface, the system needs to observe a task's user interface.
This is done compositionally.
User interfaces of combined tasks are composed of the user interfaces of the components.
For example of two tasks combined with a step combinator, only the left hand side is rendered.
Two parallel tasks are rendered next to each other.

In order for the system to actually render a task, it needs to observe the task's value, possible inputs, and user interface.
With this information, the system can then display the current state of the task, together with buttons that show the actions a user can engage in.

The final observation is to determine whether a task results in $\Fail$.
The step combinator and the choice combinator use this to prevent users from picking a failing task.




\subsection{Tasks are never done}

Tasks never terminate, they always keep reacting to events.
Editors can always be changed or cleared, and step combinators move on to new tasks.

In a step $t \Next e$, the decision to move on to e is taken by $\Next$, not by t.
The decision is based on a speculative evaluation of $e$.
The step combinators in $t \Then e$ and $t \Next e$ pass the value $v$ of $t$ to the continuation $e$.
Both steps act like $t$ as long as the step is guarded.
A step is guarded as long as the speculative evaluation $e\ v$ yields $\Fail$.
Once it becomes unguarded, the task continues as $e\ v$.
The task $t \Next e$ requires a continue event $\Continue$ in addition to the step being unguarded.
Speculative evaluation is designed so that it does not have side effects.

The step combinators give rise to a method of internal communication:
They represent data flow that \emph{follows} control flow.




\subsection{Tasks can share information}

The step combinator is one form of internal communication, where task values are passed to continuations.
Another form of internal communication is shared data.
Shared data enables data flow \emph{across} control flow, in particular between parallel tasks.
Shared data sources are assignable references whose changes are immediately visible to all tasks interested in them.
If $r$ is a reference of type $\tau$, then $\Update r$ is an editor whose value is that of $r$.

The semantics of \TOPHAT requires all updates to shared data and all enabled internal steps to be processed before any further communication with the environment can take place.


\begin{example}[Cigarette smokers]

The cigarette smokers problem \cite{books/Downey08LBOS} is a surprisingly tricky synchronisation problem.
We study it here because it demonstrates the capabilities of guarded steps.
% The problem requires waiting for two conditions, waking up only if both conditions are satisfied.
The problem is stated as follows.
In order to smoke a cigarette, three ingredients are required: tobacco, paper, and a match.
There are three smokers, each having one of the ingredients and requiring the other two.
There is an agent that randomly provides two of the ingredients.
The difficulty lies in the requirement that only the smoker may proceed whose missing ingredients are present.

Downey models availability of the ingredients with a semaphore for each ingredient.
The agent randomly signals two of the three semaphores.
The solution proposed by Downey involves an additional mutex, three additional semaphores, three additional threads called \emph{pushers}, and three regular Boolean variables.
The job of the pushers is to record availability of their ingredient in their Boolean variable, and check availability of other resources, waking the correct smoker when appropriate.

The details of the solution are not important here.
What is important is that the implementation of what is essentially deadlock-free waiting for two semaphores requires a substantial amount of additional synchronisation, together with non-trivial conditional statements.

\TOPHAT allows a simple solution to this problem, using guarded steps.
Steps can be guarded with arbitrary expressions, and the parallel combinator can be used to watch two shared editors at the same time.
Let \TS{match}, \TS{paper}, and \TS{tobacco} be references to Booleans.
The smokers are defined as follows.
\begin{TASK}
  let continue = \<<x,y>>. if x /\ y then smoke else fail in
  let tobaccoSmoker = (update match <&> update paper) >>? continue in
  let paperSmoker = (update tobacco <&> update match) >>? continue in
  let matchSmoker = (update tobacco <&> update paper) >>? continue
\end{TASK}
When the agent supplies two of the ingredients by setting the respective shares to \TS{True}, only the step of the smoker that waits for those becomes enabled. \qed

\end{example}



\subsection{Tasks are predictable}


The parallel combinator $\And$ introduces concurrency: Two things are done at the same time.
Let $t_1$ and $t_2$ be tasks.
The parallel combination $t_1 \And t_2$ stands for two independent tasks carried out at the same time.
For the system it does not matter if the tasks are executed by two people actually in parallel, or by one person who switches between the tasks.
The inputs sent to the component tasks are interleaved into a serial stream, which is sent to the parallel combinator.
We assume that such a serialization is always possible.
The tasks are truly independent of each other, all interleavings are permitted.
The environment must prefix events to $t_1$ and $t_2$ by $\First$ (first) and $\Second$ (second) respectively.
This unambiguously renames the inputs, removing any source of nondeterminism.

With concurrency comes the need for synchronisation, in situations where only some but not all interleavings are desired.
The basic method for synchronisation in \TOPHAT is built into the step combinator.
The task $t \Next e$ can only continue execution when two conditions are met:
Task $t$ must have a value $v$, and $e\ v$ must not evaluate to $\Fail$.
Programmers can encode arbitrary conditions in $e\ v$, which are evaluated atomically between interaction steps.
This allows a variety of synchronisation problems to be solved in an intuitive and straight-forward manner.

\Citet{books/Hoare85CSP} states that nondeterminism is only ever useful for \emph{specifying} systems, never for implementing them.
\TOPHAT is meant solely for implementation and does not have any form of nondeterminism.
Input events for parallel tasks are disambiguated, internal steps have a well-defined evaluation order, and internal choice is left-biased.


\subsection{Recap}

To model collaboration, one needs communication, concurrency, and synchronisation.
In \TOP, collaboration is specified on a high level of abstraction, hiding the details of communication.
For example, the cigarette smokers communicate with each other, but the programs do not explicitly mention sending or receiving events.

By focussing on collaboration instead of communication, \TOP leads to specifications closer to real-world workflows which, at the same time, can be used to generate distributed, multi-user applications to support such workflows.
