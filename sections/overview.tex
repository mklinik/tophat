% !TEX root=../main.tex

\newpage
\section{An overview}


\subsection{Language}

\begin{grammar}
  Expressions
    & e      &::= & \lambda x.\ e               & – abstraction \\
    &        &\mid& e_1\ e_2                    & – application \\
    &        &\mid& \If{e_1}{e_2}{e_3}          & – branching \\
    &        &\mid& \{\}                        & – unit \\
    &        &\mid& \{e_1, e_2\}                & – pair \\
    &        &\mid& e_1 \star e_2               & – operator \\
    &        &\mid& x                           & – variable \\
    &        &\mid& c                           & – constant \\
    &        &\mid& r                           & – reference \\
  References
    & r      &::= & \Ref e                      & – reference \\
    &        &\mid& !e                          & – dereference \\
    &        &\mid& e_1 := e_2                  & – assign \\
    &        &\mid& l                           & – location \\
    &        &\mid& p                           & – pretask \\
  Pretasks
    & p      &::= & \Edit e                     & – edit \\
    &        &\mid& \Fill \beta                 & – fill \\
    &        &\mid& \Watch e                    & – watch \\
    &        &\mid& e_1 \Next e_2               & – ask \\
    &        &\mid& e_1 \Then e_2               & – sequence \\
    &        &\mid& e_1 \And e_2                & – parallel \\
    &        &\mid& e_1 \Or e_2                 & – choose \\
    &        &\mid& \Fail                       & – fail \\
  Constants
    & c      &::= & B \in \BB                   & – boolean \\
    &        &\mid& I \in \ZZ                   & – integer \\
    &        &\mid& S \in \SS                   & – string \\
  % &        &\mid& \ldots                      & \\
  \addlinespace
  Events
    & \eta   & ::=& \alpha                      & – action \\
    &        &\mid& \Left \eta                  & – pass to left \\
    &        &\mid& \Right \eta                 & – pass to right \\
  Actions
    & \alpha & ::=& v                           & – change \\
    &        &\mid& \Empty                      & – empty \\
    &        &\mid& \Pick \pi                   & – pick \\
    &        &\mid& \Continue                   & – continue \\
  Paths
    & \pi    & ::=& \First                      & – pick first \\
    &        &\mid& \Second                     & – pick second \\
    &        &\mid& \Other \pi                  & – pick other \\
  \addlinespace
  Types
    & \tau   &::= & \tau_1 \to \tau_2           & – abstractions \\
    &        &\mid& \Unit                       & – unit \\
    &        &\mid& \tau_1 \times \tau_2        & – pairs \\
    &        &\mid& \Reference \tau             & – references \\
    &        &\mid& \Task \tau                  & – tasks \\
    &        &\mid& \beta                       & – builtin types \\
  Builtins
    & \beta  &::= & \Bool                       & – booleans \\
    &        &\mid& \Int                        & – integers \\
    &        &\mid& \String                     & – strings \\
\end{grammar}


\subsection{Values}

\begin{grammar}
  Values
    & v      &::= & \lambda x. e                & – abstraction \\
    &        &\mid& \{\}                        & – unit \\
    &        &\mid& l                           & – locations \\
    &        &\mid& c                           & – constant \\
    &        &\mid& p                           & – pretask \\
    & u      &::= & \lambda x. e                & – abstraction \\
    &        &\mid& \{\}                        & – unit \\
    &        &\mid& l                           & – locations \\
    &        &\mid& c                           & – constant \\
    &        &\mid& t                           & – task \\
  Tasks
    & t      &\mid& \Edit u                     & – edit value \\
    &        &\mid& \Fill \beta                 & – fill value \\
    &        &\mid& \Watch l                    & – watch location \\
    &        &\mid& t_1 \Then e_2               & – sequence\footnote{$\where \Observe(t_1) \neq \nothing$} \\
    &        &\mid& t_1 \Next e_2               & – ask \\
    &        &\mid& t_1 \And t_2                & – parallel \\
    &        &\mid& e_1 \Or e_2                 & – choose \\
    &        &\mid& \Fail                       & – fail \\
\end{grammar}

Notes:
\begin{itemize}
  \item Should $\Edit$ and $\Watch$ be a lazy or strict constructors?
  \item $\Then$ and $\Next$ are strict in their first argument, lazy in their second.
    It doesn't matter what the continuation is.
  \item $\And$ is strict in both arguments.
    \todo{Why?}
  \item $\Or$ is lazy in both arguments.
    Evaluating one or both options of $e_1 \Or e_2$ before the user makes a choice will result in untimely reference updates.
  \item Althoug internal steps should be evaluated without user interaction,
    $t \Then e$ \emph{is} a task value, iff $\Observe(t) = \nothing$.
    Take for example $t = \Fill \Int$.
\end{itemize}


\statefultrue


\newpage
\subsection{Typing rules}

\begin{equation*}
  \boxed{\RelationT}
\end{equation*}

\begin{mathpar}
  \userule{T-Done} \qquad \userule{T-Fail} \\
  \userule{T-Edit} \qquad \userule{T-Fill} \qquad \userule{T-Watch} \\
  \userule{T-Next} \\
  \userule{T-Then} \\
  \userule{T-And} \qquad \userule{T-Or}
\end{mathpar}


\subsection{Expression evaluation}

\begin{equation*}
  \boxed{\RelationV}
\end{equation*}
(As defined by \textcite{pierce2002types})


\subsection{Task observation}

\begin{equation*}
  \begin{array}{@{}lcl}
    \multicolumn{3}{c}{\boxed{\Observe : t \times s \to v^?}} \\
    \Observe(\Edit v\st{s})      &=& v \\
    \Observe(\Watch l\st{s})     &=& s(l) \\
    \Observe(t_1 \And t_2\st{s}) &=& \{\Observe(t_1\st{s}), \Observe(t_2\st{s})\} \\
    \Observe(\_)                 &=& \nothing
  \end{array}
\end{equation*}


\newpage
\begin{fullwidth}
\renewcommand*{\arraystretch}{4}


\subsection{Task normalisation}

\begin{equation*}
  \boxed{\RelationN}
\end{equation*}


\paragraph{Simplifying}
\todo{Is \refrule{N-And} needed or can we just use $\Observe(t)$ to check if we have a pair?}

\begin{mathpar}
  \divert{\userule{N-Then}} \\
  \userule{N-And}
\end{mathpar}


\paragraph{Stepping}

\begin{mathpar}
  \begin{array}{@{}ll}
    \userule{N-WhenStay} & \userule{N-WhenFail} \\
                         & \userule{N-WhenNext}
  \end{array}
\end{mathpar}


\paragraph{Evaluation}

(Complementing above conditional rules)

\begin{mathpar}
  \divert{\userule{N-ThenEval}} \\
  \userule{N-AndEval} \qquad \userule{N-OrEval}
\end{mathpar}


\paragraph{Values}

\begin{mathpar}
  \userule{N-Pure} \qquad \userule{N-Fail} \\
  \userule{N-Edit} \qquad \userule{N-Fill} \qquad \userule{N-Watch}
\end{mathpar}


\newpage
\subsection{Event handling}

\begin{equation*}
  \boxed{\RelationH}
\end{equation*}


\paragraph{Editors and watches}

\begin{mathpar}
  \userule{H-Change} \qquad \userule{H-Enter} \qquad \userule{H-Clear} \\
  \userule{H-Store}
\end{mathpar}


\paragraph{Stepping}

(This is the ugly part\ldots)

\begin{mathpar}
  \begin{array}{@{}ll}
    \divert{\userule{H-Stay'}} & \divert{\userule{H-Next'}} \\
    \userule{H-Stay}           & \userule{H-Next} \\
                               & \userule{H-Fail}
  \end{array}
\end{mathpar}


\paragraph{Choosing}

\begin{mathpar}
  \userule{H-First} \qquad \userule{H-Second} \qquad \userule{H-Other}
\end{mathpar}


\paragraph{Passing}

\renewcommand*{\AndOr}{\Both}
(We use $\AndOr \in \{\And, \Or\}$.
Note that \refrule{H-Pass} is the place where we reuse $\normalise$.)

\begin{mathpar}
  \divert{\userule{H-PassS}} \qquad \userule{H-Pass} \\
  \userule{H-Left} \qquad \userule{H-Right}
\end{mathpar}


\paragraph{Fallback}

(Only applicable when no other rules apply!)

\begin{mathpar}
  \userule{H-Fallback}
\end{mathpar}

\end{fullwidth}


\newpage
