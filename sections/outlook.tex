% !TEX root=../icfp2019.tex



\subsection{Outlook}

At this point we have specified a formal language for task-oriented programming,
given its semantics, and proved its safety.
The main motive to formalise this paradigm, is to be able to reason about tasks.
In future work, we plan on utilising the formalisation to do so.

Firstly, we would like to express properties of tasks and prove them.
For example, one would like to prove that, no matter what, in \cref{exm:breakfast} breakfast is always being served.
Secondly, we would like to explore what it means for two tasks to be equal.
One could have noticed that some operators have a monadic or applicative feeling.
The combination of $\And$ and $\Edit$ could form a (lax) monoidal functor,
$\Or$ is similar to applicative choice,
and $\Then$ looks like a bind operation.
We need a correct understand of equivalence of tasks,
taking the interactive setting into account,
to prove this.
Thirdly, we do not know yet if the more complex combinators of \ITASKS are expressible in the basic combinators of \TOPHAT.
We implemented \TOPHAT on top of \ITASKS, so we know it is a subset,
but we also know \ITASKS can do more.

% The work presented in this paper describes a formal foundation for task oriented programming.
% For the first time, this programming paradigm has been formalised.
% The formalisation allows us to reason about \TOP and programs written in \TOPHAT.
% So far, we have proven type safety and progress, but this is merely the beginning.
% In future work, we plan on utilising the formalisation to do much more.

% First of all, we would like to show that certain properties hold for individual programs.
% We would also like to be able to define what it means for programs to be equal.

A more in depth description of future work can be found in \cref{sec:conclusions}.
