% !TEX root=../pldi2019.tex

\section{Comparison}

In this section we compare TOP with Hoare's Communicating Sequential Processes (CSP).
The discussion here is based on the book by \citet{books/Hoare85CSP}.
We chose CSP as an example to stand for the numerous process algebras in existence, which, as far as this section is concerned, are reasonably similar.
Notions like communication with the environment and between subsystems, concurrency, and sequential composition can be found in both TOP and in process algebras.
This raises the question of how these systems relate.

We provide comparisons based on three aspects.
First, we compare the scope of the languages, as intended by the authors.
Second, we show how similar features like concurrency or communication work.
Third, we provide some example problems and illustrate how they can be solved in each language.


\subsection{Scope}

The central goal of CSP is to model the patters of behaviour of processes.
These patterns of behaviour manifest themselves in sequences of actions that actors can perform.

The central goal of TOP is to coordinate the collaboration between people who work together to reach a common goal.

CSP has a formal semantics that allows various kinds of correctness proofs, including equality of processes, and adherence to a specification.
This allows applications in program correctness, proofs of deadlock freedom, liveness, or verification of protocols.

TOP focuses less on formal correctness, and more on practical applicability.
It wants to be a language with intuitive semantics that facilitates communication between programmers and domain experts.
TOP programs are supposed to hide implementation details from domain experts while containing enough information to allow automatic generation of executable applications, including user interfaces.


\subsection{Features}

In this section we focus on certain features common to TOP and CSP, and study their respective realization.
When we point out differences, we do not argue that the different realizations are incompatible.
As a matter of fact the primitives can certainly be expressed in terms of each other, with more or less effort.
Instead, we point out how the systems emphasize certain points of view by choosing different basic building blocks.


\subsubsection*{Communication with the environment}

In CSP, communication with the environment is represented by prefixing.
The process $(a \to P)$ can engage in action $a$, after which it continues as process $P$.
In general, if $B$ is a set of events and $P(x)$ is an expression that evaluates to a process for each $x \in B$, the process $(x:B \to P(x))$ can engage in any one of the actions in $B$, after which it continues as the process determined by $P(x)$.
Hoare does not specify the language in which $P(x)$ is to be expressed.
He seems to permit any kind of mathematical formula, or any programming language.

Prefixing has no direction of sending and receiving.
Hoare uses the neutral phrase \emph{engaging in an action}.
The interpretation of whether an action stands for input or output is left to the reader.
For example, a vending machine $P = (\textit{coin} \to \textit{choc} \to P)$ is to be interpreted as taking a coin as input and producing chocolate as output.

Sending and receiving of values is modelled by giving additional structure to the names of actions.
For example, an action name could be of the form $\textit{in}.5$.
Let $B$ be the set of all actions $\textit{in}.n$ for all $n \in \mathbb{N}$.
Let $P(x)$ be an expression that for a given action of this form employs a parser that extracts the number after the dot.
The process $(x:B \to P(x))$ then reacts as if it receives the action \textit{in}, parameterized with a number.
To send a value to this process, the environment has to provide an action with a concrete number, for example $\textit{in}.7$.
Sending is therefore the willingness to engage in one concrete action of a given form, while receiving is the willingness to engage in any action of this form.

In TOP, communication with the environment is represented by editors.
A task of the form $\Enter \tau$ can receive any change event with a value of type $\tau$.
A task of the form $\Edit v$, where $v$ is of type $\tau$, can receive the same
events, and additionally the special event $\Empty$ that empties the editor.
The environment can always inspect the current value of an editor.

Editors have no notion of continuation.
Their sole purpose is to interact with the environment, retaining the last value that has been sent to them.

Editors can be used for both input and output.
The interpretation of whether an editor represents input or output is left to the reader.
An empty editor is most commonly interpreted as a prompt to input data, while a filled editor can be seen either as outputting its value, or as an input that comes with a default value.

In TOP, event values are typed to match the type of the receiving editor.
In CSP, action names are essentially strings, subject to implicit restrictions.


\subsubsection*{Communication between subsystems}

Another important feature in both TOP and CSP is communication between subsystems, that is between tasks and between processes.

CSP uses the same method for internal and for external communication, that is prefixing.
The intuitive idea is that parallel processes that all eventually are willing to engage in some action must wait for the others and then progress in one synchronized step.
This step in its own is still visible to the environment, which means the processes can not engage in this action unless the environment is also willing to.
Communication becomes internal by using \emph{concealment}.

Concealment is an operator that hides a given set of actions from the environment, which changes the semantics of prefixing for the concealed actions.
The process does not have to wait for the environment to be willing to engage in concealed actions, it can just step on its own.
In fact, the process must take any concealed steps as soon as possible, before any further communication with the environment can take place.
This means internal steps have priority over external communication.
In other words, computation before communication.
This introduces the possibility of diverging computations, that is processes which continuously take internal steps without ever being able to engage in external communication.

To exchange values over internal communication, CSP employs the same technique of decoding action names as described in the section about external communication.

TOP has two methods for internal communication, both different from its method for external communication.
There is the step combinator and there is shared data.
All tasks have values, and the step combinator in $t \Then c$ passes the value of $t$ to the continuation $c$.
The step combinator represents data flow that follows control flow.

Shared data on the other hand represents data flow across control flow.
Shared data sources are assignable references, whose changes in value are immediately visible to all tasks interested in them.

The semantics of TOP requires all updates to shared data and all enabled internal steps to be processed before any further communication with the environment can take place.
This introduces the possibility of diverging computations, where a cyclic dependency between shared data causes updates to enable steps, which cause more updates ad infinitum.


\subsubsection*{Sequential composition}

The intuition about sequential composition is to first do one thing, and once it is done, do some other thing.

In CSP, sequential composition is represented by the semicolon combinator together with the special action $\checkmark$, called \emph{success}.
We assume that if a process engages in $\checkmark$, it must be the single last action.
If that is the case, we say the process terminates successfully.
The process $P;Q$ behaves like $P$ until $P$ successfully terminates, after which it continues as $Q$.
If $P$ never terminates successfully, neither does $P;Q$

In TOP, tasks never terminate.
Nonetheless, the notion of sequential composition exists in two forms: the external and the internal step.
The task $t \Then c$ acts like $t$ as long as the step is guarded.
Once it becomes unguarded, the task continues as $cv$, where $v$ is the value of $t$.
The task $t \Next c$ requires an input event $\Continue$ in addition to the step being unguarded in order to step.

In CSP, it is the first process that decides when to step.
In TOP, it is the step combinators that make this decision.


\subsubsection*{Concurrency}
Parallel composition

\subsubsection*{Synchronization}
Synchronized actions vs. guarded transitions

\subsubsection*{Nondeterminism}


\subsection{Examples}

\begin{itemize}
\item Semaphores
\item Vending machine
\item Cigarette smokers
\end{itemize}
