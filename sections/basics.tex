% !TEX root=../main.tex

\section{Our base language}

Let us start by defining our host language.
It is a simple $\lambda$-calculus.
In addition to abstraction, application and variables,
it contains constants for booleans, integers and strings
and some basic operations on them.
We will embed our task language in this basic language.
This means we can use all the power of the host language,
such as arithmetic operations and (higher order) functions in our task language.
Because all the constructs in our host language are standard,
we will not define typing rules and semantic rules for them explicitly.
For this we refer to standard work like \textcite{pierce2002types} and \textcite{harper2016practical}.


\subsection{Syntax}

\begin{grammar}
  Expressions
    & e &::= & e_1\ e_2           & – application \\
    &   &\mid& \lambda x.\ e      & – abstractions \\
    &   &\mid& x                  & – variable \\
    &   &\mid& c                  & – constants \\
    &   &\mid& e_1 \star e_2      & – operator \\
    &   &\mid& \If{e_1}{e_2}{e_3} & – test \\
    &   &\mid& p                  & – pretasks \\
  Constants
    & c &::= & B                  & – booleans \\
    &   &\mid& I                  & – integers \\
    &   &\mid& S                  & – strings \\
  Pretasks
    & p &::= & \ldots             & (to be defined) \\
\end{grammar}
Expressions are just applications, abstractions, variables or constants.
Constants can be booleans, integers or strings.
The $\star$ represents a general notion of operators.
With $\If{}{}{}$ one can do basic branching.
The syntactic category of pretasks will be defined in the upcoming sections.
Pretasks $p$ are tasks \emph{in making}.
The difference with a \emph{task} will be discussed in \autoref{sec:tasks-vs-pretasks}.

We will use double quotation marks ($\str{}$) to denote strings.
Integers are denoted by their decimal representation,
and booleans are written $\True$ and $\False$.
In the remaining of this text,
we will make freely use of the logic operators $\land$, $\lor$,
arithmetic operators like $+$, $-$, $\times$,
and appending strings with $\pp$.
Also, we will use the standard comparison operations $<$, $\le$, $\equiv$, $\nequiv$, $\ge$, and $>$
as builtins.
Only when referring to operators in general we will use $\star$.


% \paragraph{Values}

\begin{grammar}
  Values
    & v &\mid& \lambda x.\ e  & – abstractions \\
    &   &\mid& c              & – constants \\
    &   &\mid& t              & – tasks \\
\end{grammar}
Regarding our base language, lambda abstractions are values, as are all constants.
Most important, \emph{tasks are values}.


\subsection{Typing}

\begin{grammar}
  Types
    & \tau &::= & \tau_1 \to \tau_2 & – abstractions \\
    &      &\mid& \beta             & – basic types \\
    &      &\mid& \Task \tau        & – tasks \\
    &\beta &::= & \Bool             & – booleans \\
    &      &\mid& \Int              & – integers \\
    &      &\mid& \String           & – strings \\
\end{grammar}
Typing of our expressions $e$ is as to be expected,
and won't be given in this document.
There is one big difference with respect to standard work.
This is the addition of a type for tasks $\Task \tau$.
Typing rules are of the form $\boxed{\Gamma \infers e : \tau}$,
which we read as \enquote{in environment $\Gamma$, expression $e$ has type $\tau$}.


\subsection{Evaluation}

To express evaluation,
we use the big step semantics of our host language.
Turning an expression $e$ into a value $v$ is denoted by $\boxed{e \evaluate v}$.
The rules to evaluate expressions $e$ do not defer from standard work.
Also, as tasks are values, they will not be evaluated further by the $\evaluate$ operation.
