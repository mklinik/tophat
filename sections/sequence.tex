% !TEX root=../main.tex

\section{Performing tasks one after the other}

In the previous section we have set up our interaction model of actions,
and we defined our first interactive component, the editor.
Now we can continue with the composition of tasks.
By composing tasks we
Composing tasks can be done in two ways:
\begin{enumerate*}
  \item sequential; or
  \item parallel.
\end{enumerate*}
For parallel composition we distinguish two kinds:
\begin{enumerate*}[(a)]
  \item pairing two tasks (\emph{and}-parallel); and
  \item choosing between two tasks (\emph{or}-parallel).
\end{enumerate*}
In this section we start with sequential composition.
The next two sections are about pairing and choosing.

One might think that the best way to sequence two tasks is by using a combinator taking two tasks:
the current one and the continuation.
However, we like the continuation to be parametrised.
Therefore, we take the continuation to be a \emph{function} from our host language which,
when evaluated, results in a task.
Syntactically this leads to
\begin{grammar}
  Tasks
    & t & ::=& \ldots   & \\
    &   &\mid& t \Seq e & – sequence \\
\end{grammar}
And the accompanied typing rule looks like
\begin{equation*}
  \TSeq
\end{equation*}

\subsection{Normalisation}

We can think of normalisation as a \enquote{medium step} semantics,
evaluation tasks $t$ as much as possible,
till the moment we need an event to continue.

\begin{equation*}
  \NSeq \qquad \NSeqEval
\end{equation*}

\subsection{Handling}

\begin{equation*}
  \begin{array}{lcl}
    \multicolumn{3}{l}{\Value : t \to v^?} \\
    \Value(`v)      &=& v \\
    \Value(\Edit v) &=& v \\
    \Value(\_)      &=& \nothing
  \end{array}
\end{equation*}

\begin{grammar}
  Actions
    & \alpha & ::=& \ldots & \\
    &        &\mid& \Next  & – continue with next task \\
\end{grammar}

\begin{equation*}
  \HSeqNext \qquad \HSeqStay
\end{equation*}
\begin{equation*}
  \HPass
\end{equation*}

\subsection{Example}
