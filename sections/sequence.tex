% !TEX root=../main.tex

\section{Performing tasks one after the other}

In the previous section we have set up our interaction model of events and actions,
and we defined our first interactive component, the editor.
Now that we have the core part of an interactive workflow,
we can continue with ways to compose multiple tasks.
Combining tasks can be done in two ways:
\begin{enumerate*}
  \item sequential or
  \item parallel.
\end{enumerate*}
For parallel composition we distinguish two kinds:
\begin{enumerate*}[(a)]
  \item pairing two tasks (\emph{and}-parallel); and
  \item choosing between two tasks (\emph{or}-parallel).
\end{enumerate*}
In this section we start with sequential composition.
The next two sections are about pairing and choosing.

One might think that the best way to sequence two tasks is by just following one task with another:
the current one and the continuation.
However, we like the continuation to be parametrised by the value produced by the first task.
We define a \emph{step} from one task to another as \emph{a calculation which provides the next task to proceed with}.

To accomplish this,
we take continuations to be \emph{functions}.
These are just a normal functions from our host language which,
when evaluated, result in something of type $\Task$.
Therefore,
we extend our pretasks $p$ with a sequence construct $\Then$,
saving arbitrary expressions.
\begin{grammar}
  Pretasks
    & p & ::=& \ldots        & \\
    &   &\mid& e_1 \Then e_2 & – sequence \\
\end{grammar}
The accompanied typing rule looks like
\begin{equation*}
  \userule{T-Then}
\end{equation*}
Note that typing ensures us that the left hand side $e_1$ will be a task delivering a value of type $\tau_1$.
The right hand side $e_2$ then, will use this value of type $\tau_1$,
and calculate a \emph{new} task holding a value of possibly another type $\tau_2$.


\subsection{Proceeding with the next task}

\begin{grammar}
  Tasks
    & t & ::=& \ldots        & \\
    &   &\mid& t_1 \Then e_2 & – sequence \\
\end{grammar}

We can think of normalisation as a \enquote{medium step} semantics,
evaluation tasks $t$ as much as possible,
till the moment we need an event to continue.

\begin{gather*}
  \userule{N-ThenStay} \\
  \userule{N-ThenFail} \\
  \userule{N-ThenCont}
\end{gather*}

\begin{margintext}{Aside: Steps and the step combinator}
Again a side note for the iTasks guru.
In this section we introduced a way to step from one task to another.
How does this compare to the step combinators found in the iTasks framework?
Which combinator does $\Then$ correspond to?

From the multiple options that we have,
only \type{(>>=)}, \type{(>>-)} and \type{(>>\texttilde)} have the right type.
Normalisation rules \refrule{N-ThenStay}, \refrule{N-ThenFail} and \refrule{N-ThenCont} ensure stepping without any user interaction,
i.e. users are not presented with a continue button.
Therefore our $\Then$ constructor corresponds mostly to the iTasks \type{(>>-)} combinator.
\end{margintext}

\begin{margintext}{Aside: Failure and stepping}
\end{margintext}



\subsection{Handling}

\begin{grammar}
  Actions
    & \alpha & ::=& \ldots & \\
    &        &\mid& \Next  & – continue with next task \\
\end{grammar}

\begin{equation*}
  \userule{H-Next} \qquad \userule{H-Stay}
\end{equation*}
\begin{equation*}
  \userule{H-PassS}
\end{equation*}

\subsection{Example}
