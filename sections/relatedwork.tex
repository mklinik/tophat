% !TEX root=../icfp2019.tex



\section{Related work}
\label{sec:relatedwork}



\paragraph{iTasks}

As mentioned earlier, iTasks is an implementation of \TOP. iTasks has many
features, and its basic combinators are versatile and powerful. Simpler
combinators are implemented by restricting the powerful ones. This is useful for
everyday programming, where having lots of functionality at one's fingertips is
convenient and efficient.

There have been two previous papers that describe semantics of iTasks, by
\citet{conf/ifl/KoopmanPA08} and \citet{conf/ppdp/PlasmeijerLMAK12}.
Both give a different semantics in the form of minimal implementations of a
subset of the interface of iTasks. These semantics however do not make an
explicit distinction between the host language and task language and they do not
provide a formal semantics, which makes formal reasoning difficult.


% Our work differs in three major ways.
% First, we make an explicit distinction between the host language and the task
% language, to emphasise their boundaries.
% Second, we make use of separate semantic functions for querying the current task
% value, determining the continuation after an input event, and producing a user
% interface.
% In iTasks and its aforementioned semantics, these are integrated into the
% \CL{Task} datatype.
% Third, our system does not have the notion of task stability.
% When desired, stability can be introduced by the programmer, but the system
% itself makes no use of it.
% We argue that this does not impact the expressiveness of our language.

% mTasks is another implementation of TOP, designed for coordination of IoT devices. \alert{cite MSc Lubbers}
% mTasks has been used in a demonstrator for home automation. \alert{cite MSc Andrade}



\subsection{Worfklow modeling}

Much research has been done into workflow modeling. These works focus on
describing the collaboration between subsystems, rather than the communication
between them.
The systems described here follow a \emph{boxes and arrows} model of specifying workflows.
Control flow, represented by arrows, usually can go unrestricted from anywhere to anywhere else in a workflow.
We see \TOP as the functional programming of workflows, as opposed to this GOTO style.


\paragraph{Workflow patterns}

Workflow patterns are regarded as special kind of the design patterns in
software engineering. They identify recurring patterns in workflow systems, much
like the combinators defined by \TOPHAT. Work by Van der
Aalst~\cite{journals/dpd/AalstHKB03} defines a comprehensive list of these
pattens, and examines their availability in industry workflow software.
Workflow patterns are usually described in terms of control flow graphs, and no
formal specification is given, which makes comparison and formal reasoning more
difficult.

\paragraph{Workflow nets}

Workflow nets~\cite{journals/jcsc/Aalst98} allow for the modeling and analysis
of business processes. They are graphical in nature, and clearly display how
every component is related to each other. A downside of Workflow nets is that
they do not facilitate higher order constructs and that they are often not
directly executable.

\paragraph{YAWL}

This is not always the case however. A language based on workflow nets that is
actually directly executable is YAWL by van der
Aalst~\cite{DBLP:journals/is/AalstH05}. It facilitates modeling and execution of
dynamic workflows, with support for AND, OR and XOR workflow patterns. As
mentioned, YAWL programs consist of Workflow Nets, and are therefore programmed
visually.

\paragraph{BPEL}

BPEL~\cite{bpel} is another popular business process language. The standardized
language allows for the specification of actions within business processes,
using an XML format. Processes specified in BEPL are executable, just like YAWL.



\subsection{Process algebras}

The central objective of processes is to model patterns of their behaviour.
These patterns of behaviour manifest themselves in sequences of actions that processes can engage in.
Actions can be events from the environment, or signals send internally between processes.
Processes are a way to model synchronisation patterns.

% \begin{quote}
%   \noindent In \TOP, communication is a means to an end. \\
%   In \CSP, communication is the central matter of discourse.
% \end{quote}

%%NOTE: Already said in section intro --TS
% Despite the different origins, \TOP and \CSP feature concepts that serve similar purposes.

%%NOTE: Focus on what TOP is good at --TS
% \CSP has a formal semantics that allows various kinds of correctness proofs, including equality of processes, and adherence to a specification.
% This allows applications in program correctness, proofs of deadlock freedom, liveness, or verification of protocols.
%
% \TOP focuses less on formal correctness, and more on practical applicability.
The big difference between processes and tasks is the intended level of abstraction.
While processes are used to explicitly model low-level details about communication, tasks hide these details and provide high-level communication mechanisms to the programmer.
It wants to be a calculus with intuitive semantics that facilitates communication between programmers and domain experts.
Such programs are supposed to hide implementation details from domain experts while containing enough information to allow automatic generation of executable applications, including user interfaces.



\paragraph{Communication}

Both tasks and processes have two sorts of communication: with the environment, and between subsystems.
In both paradigms, communication with the \emph{environment} is input and output.
They block evaluation of programs until the environment sends or receives events.
In both paradigms, communication \emph{between subsystems} does not block.
They evaluate programs as far as possible until further external input is required.

Processes communicate with the environment by sending or receiving actions
The \CSP process $(a \to P)$ can engage in action $a$, after which it continues as process $P$.
% Prefixing has no direction of sending and receiving.
Hoare uses the neutral phrase \emph{engaging in an action}.
The interpretation of whether an action stands for input or output is left to the reader.
For example, a vending machine $P = (\textit{coin} \to \textit{choc} \to P)$ is to be interpreted as taking a coin as input and producing chocolate as output.
%%NOTE: Not that important I think, we don't use it in the rest of the text. --TS
% In general, if $B$ is a set of events and $P(x)$ is an expression that evaluates to a process for each $x \in B$, the process $(x:B \to P(x))$ can engage in any one of the actions in $B$, after which it continues as the process determined by $P(x)$.
% Hoare does not specify the language in which $P(x)$ is to be expressed.
% He seems to permit any kind of mathematical formula, or any programming language.

Sending and receiving of values is modelled by giving additional structure to the names of actions.
For example, an action name could be $\textit{in}.5$, which can be interpreted as inputting the value 5.
%
In \TOP, input values are typed to match the type of the receiving editor.
In \CSP action names are essentially strings, subject to implicit restrictions.



\paragraph{Communication between subsystems}

%
% \CSP's semicolon is like an internal step $t \Then e$ in \TOP where $t$ uses $\Unit$ to signal when it is done, and $e$ never fails.
\CSP uses prefixing for both internal and external communication.
Prefixing becomes internal by using \emph{concealment}.
Processes must take any concealed steps as soon as possible, before any further communication with the environment can take place.
This means concealed actions have priority over exposed ones.
This introduces the possibility of diverging computations, that is processes which continuously take internal steps without ever being able to engage in external communication.


% \paragraph{Sequential composition}

% In \CSP, sequential composition is represented by the semicolon combinator together with the special action $\checkmark$, called \emph{success}.
% We require that if a process engages in $\checkmark$ at all, it must be its single last action.
% When that happens, we say the process terminates successfully.
% The process $P;Q$ behaves like $P$ until $P$ terminates successfully, after which it continues as $Q$.
% If $P$ never terminates successfully, neither does $P;Q$



\paragraph{Concurrency}

Both tasks and processes are models of \emph{multiprogramming}, as opposed to \emph{multiprocessing}.
This means that one processor evaluates multiple programs in an interleaving fashion.
% instead of multiple processors.
Multiprogramming involves three aspects: concurrency, synchronisation, and nondeterminism.

In \CSP, there are two different combinators for parallel composition: parallel and interleave.
The parallel process $P \parallel Q$ can take $P$-steps and $Q$-steps in arbitrary interleaving for actions unique to $P$ and $Q$.
Actions in the alphabets of both $P$ and $Q$ must be taken in synchronisation, so if one process wants to take such a step, it must wait until the other is ready to do so.
Synchronised steps are the only occasion where two processes actually do something at the same time.
%
The interleaving operator $P \mid\mid\mid Q$ does not synchronise any actions of $P$ and $Q$.
All interleavings are permitted.
Actions that occur in both alphabets are nondeterministically taken by either $P$ or $Q$.



\paragraph{Synchronisation}

Synchronisation means that an agent has to pause execution until some condition is met.
The need for synchronisation arises quite naturally in countless variations in situations involving concurrency.
For multiprogramming, synchronisation always means that some of the possible interleavings are forbidden.

For example, the mutual exclusion problem for two parallel processes $a_p \to b_p \to \text{STOP} $ and $a_q \to b_q \to \text{STOP}$ can be stated as:
In no interleaving should there be two adjacent $a$'s.
%
The mutual exclusion problem for two parallel tasks can be stated as follows.
Let \TS{inc} and \TS{dec} be tasks that increment and decrement some shared counter.
Then, in \TS{(inc x >>? dec) <&> (dec x >>? inc)}, the shared counter should at no point be greater than 1.
This means that in no interleaving should there be two adjacent \TS{inc}'s.

The basic method for synchronisation in \CSP is synchronised prefixing.
If some action $a$ is in the alphabets of both $P$ and $Q$, then their parallel composition $P \parallel Q$ can take an $a$-step only if both $P$ and $Q$ are ready to take an $a$-step, in which case they both take this step simultaneously.
Both have to wait for the condition that the other process is ready to take the step.
All synchronisation problems in \CSP must be solved by employing synchronised steps in some form.



\paragraph{Nondeterminism}

Nondeterminism means that a system can react to the same input in different ways, the choice of which can not be influenced by the environment.

\CSP has an operator to explicitly introduce nondeterminism.
Furthermore, nondeterminism can arise from the combination of some other combinators, for example choice and concealment.
%
Hoare states that nondeterminism is only useful for \emph{specifying} processes, never for \emph{implementing} them \cite{books/Hoare85CSP}.
\CSP can be used for both.
A process with nondeterministic behaviour must always be regarded as a specification, while a deterministic process can be seen as specification or implementation.



\subsection{Related web services}


\paragraph{IFTTT}

If This Then That (IFTTT)~\cite{IFTTT} is a web service that allows users to write and
configure simple conditional statements called applets, that can interact with
web services and IoT devices. These applets can be seen as tiny workflows, that
facilitate collaboration between different services and platforms. The
complexity of the flow is very limited however, and is not geared towards humans
collaborating.

\paragraph{Google forms \& Wufoo}

Google forms~\cite{googleforms} and Wufoo~\cite{wufoo} are web based survey administration apps that allows
users to compose forms and gather data from them. They are comparable to TOP and
iTasks in that they provide an easy way for users to construct forms on the web.
However, Google forms and Wufoo do not allow users to define what the system
then should do with this information, and can therefore not be regarded as a
workflow or business process modeling systems.

\paragraph{Chorus} % (http://www.chorus-home.org/)

Chorus~\cite{chen2017chorus} is a visual programming environment for online
collaboration apps. The goal of Chorus is to allow users to program their own
application, though which a collective task can be coordinated. Users work on a
preset data-type that drives the behavior of the user defined applications.


\subsection{Functional Reactive Programming}

Functional Reactive Programming (FRP) is a paradigm to describe dynamic changes of values in a declarative way.
This is done by specifying networks of values, called behaviors, that can depend on each other and on external events.
Behaviors can change over time, or triggered by events.
When a behavior changes, all other behaviors that depend on it are updated automatically.
The underlying implementation that takes care of the updating usually can tie input devices, like mouse and keyboard, to event streams and behaviors to output facilities, like text fields.
This allows for declarative specifications of applications with user interfaces.

The idea of FRP was pioneered by \citet{conf/icfp/ElliottH97}, in the meantime there are many variants and implementations, with reactive-banana one of the most well-known \cite{reactive-banana}.

FRP and \TOP are different systems that have different goals in mind.
Whereas FRP expresses automatically updating data dependencies, \TOP expresses collaboration patterns.
\TOP has no notion of time.
Tasks can not change over time, while behaviors can.
The biggest conceptual difference between a workflow in \TOP and a data network in FRP is that an event to a task only causes updates up until the next step, while an event in FRP propagates through the whole network.

That being said, there are some concepts that are similar in \TOP and FRP.
The \emph{stepper} behavior for example is associated with an event and yields the value of the most recent event.
This is similar to editors in \TOP.
Furthermore, both systems can be used to declaratively program user interfaces, albeit in FRP the programmer has to construct the GUI elements manually, and connect inputs and outputs to the correct events and behaviors.
In \TOP graphical user interfaces are automatically derived.


\subsection{Session types}

Session types are a type discipline that can be used to check whether communicating programs conform to a certain protocol.
Session types are expressions in some process calculus that describe the input/output behavior of such programs.
Session types are useful for programming languages where modules communicate with each other via messages, like CSP, $\pi$-calculus, or Go, to name a few.
The only form of messages in \TOP are input events which drive execution, but modules do not communicate using messages.
Therefore, session types are not applicable to \TOP in the sense used in the literature.

Formal reasoning about \TOP programs is one of our future goals for \TOPHAT.
The ideas and techniques of session types could be useful for specifying that a list of inputs of a certain form leads to desired task values.
The details are a topic for future work.
