% !TEX root=../icfp2019.tex



In this paper, we set out to develop a formal basis for \TOP, called \TOPHAT (TopHat).
Our goal is to specify the basic building blocks of declarative workflows.
We clearly separate them from general purpose programming concepts.
This allows us to prove properties like progress and type preservation.
\TOPHAT should be powerful enough to model complicated real-world situations,
without losing opportunities for formal reasoning.


We present a calculus for modelling declarative workflows, embedded in a simply typed lambda-calculus.
We develop an operational semantics that is driven by user inputs.
The semantics of the task language is clearly separated from the semantics of the underlying host language.
Along with the semantics, we present the following semantic observations on tasks: the current value, whether a term is stuck, the current user interface, and the accepted inputs.
\fixme{we do not provide observation for user interface!}
%%NOTE: iTasks things are moved to related work
% All these observations exist in iTasks, albeit combined into one big type.
By separating them in the style of a deep embedding \cite{conf/cefp/Gibbons13}, we make explicit where and where not, they depend on each other.

Additionally, we implemented the whole semantic system in the dependently typed programming language Idris \cite{journals/jfp/Brady13},
to gain confidence for our system and check practical applicability.
Furthermore we compare \TOPHAT  with the process algebra \CSP, to show how their concepts, like communication, and sequential and parallel composition, relate.
We show that, where process algebras focus on the \emph{coordination} of processes and the \emph{communication} between them,
\TOP, and therefore \TOPHAT, focus on supporting \emph{tasks} and model ways to \emph{collaborate} on them.



\begin{itemize*}
  \item A calculus to model workflows, which can be used in a modular way and are driven by user inputs.\\
  \item Embed this calculus in a simply typed $\lambda$-calculus.\\
  \item Its operational semantics, presented and defined in a layered way.\\
  \item Semantic observations on the calculus which can be used to:\\
  \begin{itemize*}
    \item calculate stuck configurations,\\
    \item associate a value with a task,\\
    \item draw a user interface (\UI) for a task,\\
    \item calculate input possibilities for the user.\\
  \end{itemize*}
  \item A clear separation between \TOP principles and general purpose programming constructs.\\
\end{itemize*}
