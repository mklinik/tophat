% !TEX root=../pldi2019.tex



\section{Introduction}

Task-Oriented Programming (\TOP) is a programming paradigm aimed at writing interactive multi-user applications in a declarative way \cite{conf/ppdp/PlasmeijerLMAK12}.
\TOP has two aspects.
Firstly, \TOP defines the primitive building blocks that are useful for high-level descriptions of how users collaborate with each other and with applications.
These building blocks are \emph{editors}, \emph{composition}, and \emph{shared data}.
Secondly, \TOP defines a type-driven way to generate applications, including graphical user interfaces, from workflows modelled with said building blocks.

In this paper we study the essence of \TOP.
We claim that at the heart of \TOP lie modular interactive workflows.
Workflows because \TOP programs coordinate collaboration between people.
Interactive because progress of \TOP programs is driven by user input.
Modular because the embedding in a strongly-typed functional language allows powerful abstractions using type-driven techniques and higher-order functions.

Interactive workflows are called \emph{tasks}.
Tasks stand for units of work in the real world, assigned to people.
People can work together in a number of ways, and this is reflected in \TOP by task combinators.
There is sequential composition, parallel composition, and choice.
People need to communicate in order to engage in these forms of collaboration.
This is reflected in \TOP by three kinds of communication mechanisms.
There is data flow \emph{alongside} control flow, where the result of a task is passed onto the next.
There is data flow \emph{across} control flow, where information is shared between multiple tasks.
Finally, there is communication with the \emph{outside} world, where information is entered into the system via input events.
The end points where the outside world interacts with \TOP applications are called editors.
In generated applications, editors can take many forms, like input fields, selection boxes, or map widgets.

\TOP has been used to model an incident management tool for the Dutch coast guard~\cite{conf/iscram/LijnseJP12}.
Also it has been used numerous times to prototype ideas for Command and Control~\cite{theses/nlda/Kool17, theses/radboud/Stutterheim17}, and in a case study for the Dutch tax authority \cite{conf/sfp/StutterheimAP17}.



% \paragraph{Motivation}

In this paper, we set out to develop a formal basis for \TOP, called \TOPHAT (TopHat).
Our goal is to specify the basic building blocks of declarative workflows.
We clearly separate them from general purpose programming concepts.
This allows us to prove properties like progress and type preservation.
With \TOPHAT it should be possible to express complicated real-world situations,
while still being open for formal reasoning.



\paragraph{Contributions}

We present a calculus for modelling declarative workflows, embedded in a simply typed lambda-calculus.
We develop an operational semantics that is driven by user inputs.
The semantics of the task language is clearly separated from the semantics of the underlying host language.
Furthermore, we present the following semantic observations on tasks: the current value, whether a term is stuck, the current user interface, and the accepted inputs.
% All these observations exist in iTasks, albeit combined into one big type.
By separating them in the style of a deep embedding \cite{conf/cefp/Gibbons13}, we make explicit where, and where not, they depend on each other.

Furthermore we compare our calculus with the process algebra \CSP, to show how their concepts, like communication, and sequential and parallel composition, relate.
We show that, where process algebras focus on the \emph{coordination} of processes and the \emph{communication} between them,
\TOP, and therefore \TOPHAT, focus on supporting \emph{tasks} and model ways to \emph{collaborate} on them.



\paragraph{Overview}

In Section~\ref{sec:example} we demonstrate the functionality of \TOPHAT by means of an example,
Section~\ref{sec:comparison} compares \TOP and \TOPHAT to \CSP.
Section~\ref{sec:language} introduces the \TOPHAT calculus syntax
and Section~\ref{sec:semantics} the semantics.
Then in Section~\ref{sec:properties} we show that certain properties hold for our calculus.
We take a look at related work in Section~\ref{sec:relatedwork}
and conclude in Section~\ref{sec:conclusions}.
