% !TEX root=../main.tex

In this report we present a simple system to model interactive workflows using tasks.
By using five basic constructs,
each with its own characteristics,
we will show how to express task based systems.
Our language is capable of expressing the majority of programs that could be written in the \ITASKS\ system.

In the next sections we will gradually develop our language.
Each section will introduce one of the following basic constructs,
making our language more powerful after every addition:
\begin{itemize}
  \item editors with a value ($\Edit v$) and without a value ($\Empty$);
  \item sequential composition of tasks ($t \When e$);
  \item pairing tasks ($t_1 \And t_2$);
  \item giving a choice between tasks ($t_1 \Or t_2$);
  \item watching shared data ($\Watch l$).
\end{itemize}

Compared to previous attempts,
this system distinguishes itself by the following.
\begin{itemize}
  \item
    There is a clear distinction between the underlaying \emph{host language} and the task layer (\emph{object language}) on top of it.
  \item
    There is no notion of values which can be stable or unstable.
    Our language has pure values lifted into the task world ($`e$)\footnote{
      This makes the system a pointed functor.}
    and editors which have a value or don't have a value.
  \item
    Tasks do not need to be identified by a task identifier.
    Events are based on the \emph{structure} of the current task.
  \item
    Events are not handled by the user, but are build into the semantics.
  \item
    Entering some information into the system is not a one-shot action.
    Editors keep asking for input continually.
    Thus repeatedly asking for information does not need to be modelled with recursion.
    The next task is only executed under preprogrammed internal conditions or external action by the user.
  \item
    We make use of multiple semantic functions that describe different aspects of the system.
    At the core, we assume a big step semantics for the host language.\footnote{
      We use a $\lambda$-calculus with some simple extensions like $\If\Then\Else$, pairs, and references.}
    On top of this there are \emph{normalisation} semantics of tasks,
    performed after each event handle step,
    and the \emph{handling} of events itself.
    Next to these three core semantics,
    there are also semantic functions querying the current value of a task
    or giving enabled options.
\end{itemize}

The remaining of this report is structured as follows.
In the first section we will start with the definition of our host language,
the pure $\lambda$-calculus,
and an empty object language.
Thereafter, in the next five sections, we will gradually define our object language,
extending the properties of our host language when needed.
We strive to keep the host language as small as possible.
At the end of the report,
we will give an overview of our our system,
including all static and dynamic rules defined.
