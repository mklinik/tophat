% !TEX root=../icfp2019.tex



\section{Introduction}

\fixme{Common intro??}

\subsection{Tasks}

Many applications these days are developed to support workflows in institutions and businesses.
Take for example expense declarations, order processing, and emergency management.
Some of these workflows occur on the boundary between organisations and customers,
like flight bookings or tax returns.
What they all have in common is
that they need to interact with different people (end users, tax officers, customers, etc.)
and they use information from multiple sources (input forms, databases, sensors, etc.).

We call interactive units of work based on information sources \emph{tasks}.
% Tasks stand for units of work in the real world, assigned to people.
Tasks model real world collaboration between users,
are driven by work users do,
and are assigned to some user.
Users could be people out in the field or sitting behind their desks,
as well as machines doing calculations or fetching data.



\subsection{Task-oriented programming}

% Task-Oriented Programming (\TOP) is a programming paradigm aimed at writing interactive multi-user applications in a declarative way \cite{conf/ppdp/PlasmeijerLMAK12}.
Task-oriented programming (\TOP) is a programming paradigm which aims to be the sweet spot between faithful modelling workflows
and rapid prototyping of multi-user web applications supporting these workflows.
% Task-oriented programming (\TOP) is a programming paradigm to support these ways of working.
\TOP focusses on modelling collaboration patterns.
This gives rise to user's need to interact and share information.
Next to that, \TOP automatically provides solutions to common development jobs like designing \GUI\ s, connecting to databases, and communicating between servers and clients.

Therefore,
a language that supports \TOP should choose the right level of abstraction to support two things.
% \TOP has two aspects.
% First, it should allow to specify tasks from real world scenarios.
Firstly, it should provide primitive building blocks that are useful for high-level descriptions of how users collaborate with each other and with machines.
These building blocks are \emph{editors}, \emph{composition}, and \emph{shared data}.
% Second, it should be able to generate multi-user web applications to support these scenarios.
Secondly, it should be able to generate applications, including graphical user interfaces, from workflows modelled with said building blocks.

Users can work together in a number of ways, and this is reflected in \TOP by task compositions.
There is sequential composition, parallel composition, and choice.
Users need to communicate in order to engage in these forms of collaboration.
This is reflected in \TOP by three kinds of communication mechanisms.
There is data flow \emph{alongside} control flow, where the result of a task is passed onto the next.
There is data flow \emph{across} control flow, where information is shared between multiple tasks.
Finally, there is communication with the \emph{outside} world, where information is entered into the system via input events.
\fixme{Should this be mentioned earlier?}
The end points where the outside world interacts with \TOP applications are called editors.
In generated applications, editors can take many forms, like input fields, selection boxes, or map widgets.



\subsection{Utilisation}


Currently, we know of two frameworks using \TOP: \ITASKS and \MTASKS.

\ITASKS is an implementation of \TOP, in the form of a shallowly embedded domain-specific language in the lazy functional programming language Clean.
It is a library that provides editors, monadic combinators, and shared data sources.
\ITASKS uses the generic programming facilities of Clean to derive rich client and server applications from a single source.
It has been used to model an incident management tool for the Dutch coast guard~\cite{conf/iscram/LijnseJP12}.
Also it has been used numerous times to prototype ideas for Command and Control~\cite{theses/nlda/Kool17, theses/radboud/Stutterheim17}, and in a case study for the Dutch tax authority \cite{conf/sfp/StutterheimAP17}.

\MTASKS is a subset of \ITASKS,
focussing on \IOT devices and deployment on micro controllers.
\fixme{Add examples.}

\fixme{Say what lacks in these approaches: no formal reasoning about properties.}



\subsection{Scope}

In this paper, we set out to develop a formal basis for \TOP, called \TOPHAT (TopHat).
Our goal is to pave the way for formal treatment of \TOP programs.

\ITASKS is the de-facto reference implementation of \TOP.
It has been designed for developing real-world applications, and is constantly being extended and improved with this goal in mind.
All the bells and whistles of \ITASKS, the different variations of task combinators, and the details that come with real-world requirements, make it hard to see what the essence of \TOP is.
It also makes formal reasoning about \TOP programs impossible.

In this paper, we want to take a step back and look at the essence of \TOP.
We do this both formally and informally.
Informally in the sense that we give an intuitive description of the features that define task-oriented programming.
Formally in the sense that we develop a calculus which formalizes these features as language constructs, and we give them semantics in the style that is common in programming language research.

One of the defining aspects of \ITASKS is its embedding in a functional programming language.
This creates a synergy where \ITASKS profits from the expressivity of Clean, while enhancing the language with functionality for user interaction.
The tight integration of task DSL and host language makes it sometimes difficult to see where the boundaries are.

In \TOPHAT, we separate the task layer and the underlying host language, both syntactically and semantically.
In this way we make explicit which of the synergetic effects of \TOP come from the task layer, and which come from functional programming.


\subsection{Contributions}

Our contributions to workflow modelling, functional programming language design, and rapid application development are as follows.


\begin{itemize}
  \item
    We describe the essential concepts of task-oriented programming.

  \item
    We present a formal calculus for modelling declarative workflows, embedded in a simply typed lambda-calculus.
    This calculus is based on the aforementioned essential \TOP concepts.

  \item
    We develop an operational semantics that is driven by user input.
    The semantics of the task language is clearly separated from the semantics of the underlying host language.

  \item
    Along with the semantics, we present the following semantic observations on tasks:
    the current value, whether a term is stuck, the current user interface, and the accepted inputs. \fixme{we do not provide observation for user interface!}

  \item
    We prove progress and type preservation for our calculus.

  \item
    Using both the essential concepts and the formal calculus, we compare \TOP with multiple related works, in areas ranging from business process modelling to process algebras and reactive programming.

  \item
    We implemented the whole semantic system in the dependently typed programming language Idris \cite{journals/jfp/Brady13}.

  \item
    %To create executable applications, we implemented \TOPHAT in iTasks.

    To create executable applications, we implemented the task layer of \TOPHAT in iTasks.
    This also demonstrates that the former is a subset of the latter.


\end{itemize}


\subsection{Structure}

In Section~\ref{sec:example} we demonstrate the functionality of \TOPHAT by means of an example,
Section~\ref{sec:intuition} gives an overview of the essential concepts of \TOP and \TOPHAT.
Section~\ref{sec:language} introduces the \TOPHAT calculus syntax
and Section~\ref{sec:semantics} the semantics.
Then in Section~\ref{sec:properties} we show that certain properties hold for the calculus.
We take a look at related work in Section~\ref{sec:relatedwork}
and conclude in Section~\ref{sec:conclusions}.
